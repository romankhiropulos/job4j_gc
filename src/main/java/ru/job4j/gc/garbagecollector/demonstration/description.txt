1.
    1) new User(28, "Иван", countDeletedObj);
    2) Примем тот факт, что используется 64 битная JVM, и мы не отключим сжатые ссылки и не будем использовать
       более 32 ГБ кучи. Т.о. размер заголовка объекта составляет 12 байт(12 байт необходимо для информации заголовка:
       MarkWord(HashCode, Garbage Collection Information, Lock), TypeInformationBlockPointer),
       переменные-ссылки на объект занимают 4 байта. Размер объекта в 64 битной JVM необходимо расширить до значения,
       кратного 8. Это сделано для того, чтобы адрес в памяти всегда был кратным машинному слову.

       У объекта класса User три поля: int age, String name и Count countDeletedObj. Рассчитаем объект класса User с
       initial полями.
        а) Заголовок объекта класса User занимает в памяти 12.
        б) Примитив int, хранящий возраст пользователя, занимает 4 байта информации.
        в) Ссылка на объект с именем пользователя(name) занимает 4 байта.
        г) Ссылка на объект Count занимает также 4 байта.
        Получается, что объект класса User со значениями полей по умолчанию
        занимает: 12 + 4 + 4 + 4 = 24 байта.

            Поле с именем пользователя(name) представляет собой объект класса String. Судя по деббагеру, данный объект
            состоит из четырех полей: массива value со значениями типа byte, поля coder типа byte, поля hash типа int
            и поля hashIsZero типа boolean.
            а) Заголовок объекта name занимает 12 байт памяти.
            б) Ссылка на объект массива byte занимает 4 байта.
            в) Поля примитивы - coder + hash + hashIsZero = 1 + 4 + 1 = 6 байт
            Получается, что объект класса String со значениями полей по умолчанию
            занимает: 12 + 4 + 6 + 2(выравнивание) = 24 байта.

                Поле value класса String это объект массив, поэтому заголовок, помимо 12 байт, еще дополнительно
                занимает 4 байта для хранения значения длины массива.
                Имя пользователя "Иван" состоит из четырех значений типа byte, лежащих в массиве value, занимая 4 байта.
                Получается, что объект массива с символами имени пользователя
                занимает: 16 + 4 + 4(выравнивание) = 24 байт.

            Поле countDeletedObj состоит из заголовка объекта и поля int.
            Объем занимаемой памяти: 12 + 4 = 16 байт

        Итого, объект класса User с именем "Иван" требует: 24 + 24 + 24 + 16 = 88 байт.

2.
    Запуск метода main() в классе Main с ключами -Xmx2m -Xms4m
    Объекты класса User создаются в цикле и их ссылки никуда не записываются  в коде программы, т.о. каждый созданный
    объект класса User кандидат на удаление сборщиком мусора.
    Примерно после создания 1870 объектов запускается сборка мусора и удаление объектов User. Этом говорит о том, что
    после создания ~1870 объектов класса User переполняется young generation, и запускается minor GC.
    Второй раз очистка происходит при создании ~ 3600 объектов (предполагаю, что это второй запуска minor GC).
    В третий раз очистка происходит при ~6300 объектах, что позволяет предплоложить возникновение ситуации переполнения
    old generation и запуска major GC.
    Четвертый запуск очистки произошел на ~ 9150 объектах, затем программа завершилась.